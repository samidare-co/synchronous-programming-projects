node compteur_evt(e : bool) returns (c : int)
let
    c = (if e then 1 else 0) -> if e then pre c + 1 else 0;
tel

node detecteur(mvt, onoff, hs: bool) returns (alarme: bool)
var compteur : int;
let
    reset
        compteur = compteur_evt(mvt and hs);
        alarme = false -> (if compteur >= 5 then true else pre alarme);
    every not onoff
tel

node switch3(b : bool; s : int) returns (last o : int = 0) 
let

    automaton 
        state Idle 
            do 
            unless b then Increment 
        
        state Increment
            do o = last o + s
            unless b then Multiply 
            
        state Multiply
            do o = last o * s
            unless b then Idle
    end 
tel


node detecteur_auto(mvt, onoff, hs: bool) returns (accept : bool)
let
    automaton
        state Desactive 
            do accept = false; 
        (*-- 如果 onoff 被激活，则切换到 Attente 状态*)
            unless onoff then Attente
        (*-- 等待运动状态*)
        state Attente
            var time : int;
            do time = (0 fby time) + (if hs then 10 else 0); accept = false ;
        (*-- 当计数器达到  50ms 的连续运动时，触发报警，切换到 Alarme 状态*)
            until time >= 50 then Alarme
            unless not mvt then Attente | onoff then Desactive
        (*-- 如果 active 被关闭，返回 Desactive 状态*)
        (*-- 报警状态*)
        state Alarme 
            do accept = true ;
            (*-- 报警保持激活*)
        (*-- 如果 active 被关闭，返回 Desactive 状态*)
            unless onoff then Desactive
    end
tel





node detecteur_toto(mvt, onoff, hs: bool) returns (accept : bool)
let
    automaton
        state Desactive 
            do accept = false
        (*-- 如果 onoff 被激活，则切换到 Attente 状态*)
            unless mvt and hs and onoff then C1 | (not (mvt and hs) and onoff) then Attente | not onoff continue Desactive
        
        (*-- 等待运动状态*)
        state Attente  
            do accept = false
        (*-- 如果检测到连续的运动，则计数*)
                
        (*-- 当计数器达到 5(表示 50ms 的连续运动)时，触发报警，切换到 Alarme 状态*)
            
            unless mvt and hs and onoff then C1 | not onoff then Desactive
        (*-- 如果 onoff 被关闭，返回 Desactive 状态*)

        state C1
            do accept = false
            until mvt and hs and onoff then C2 | (not (mvt and hs) and onoff) then Attente | not onoff then Desactive

        state C2
            do accept = false
            until mvt and hs and onoff then C3 | (not (mvt and hs) and onoff) then Attente | not onoff then Desactive

        state C3
            do accept = false
            until mvt and hs and onoff then C4 | (not (mvt and hs) and onoff) then Attente | not onoff then Desactive

        state C4
            do accept = false
            until mvt and hs and onoff then Alarme | (not (mvt and hs) and onoff) then Attente | not onoff then Desactive

        (*-- 报警状态*)
        state Alarme 
            do accept = true
            (*-- 报警保持激活*)
        (*-- 如果 onoff 被关闭，返回 Desactive 状态*)
            until not onoff then Desactive
    end
tel

node f3() returns (o : int) 
let
    automaton 
        state A

            do o = 0 fby (o + 1)

            until o >= 3 then A

    end 
tel

node chrono2(start_stop, rst, hs: bool) returns (last time: int = 0)
let
    automaton
        state Stop 
            do 
                    time = if rst then 0 else last time
            unless start_stop then Running 
        
        state Running
            do 
                    time = if rst then 0 else if hs then last time + 1 else last time;
            unless start_stop then Stop 
        
    end
tel

node f(x : float :: .) returns (c : bool :: .; o : float :: . on true(c)) 
let
    c = true fby true fby true fby false;
    o = x when c +. 1.0 ;
tel


node chrono3(start_stop, rst, hs, pause: bool) returns (last displayed_time: int = 0)
var last internal_time : int = 0;
    last gele : bool = false;
let
    automaton
        state Stop 
            do 
                    internal_time = if rst then 0 else last internal_time;
                    displayed_time = if gele then last displayed_time else internal_time;
                    gele = last gele <> pause;
            unless start_stop then Running 
        
        state Running
            do 
                    internal_time = if rst then 0 else if hs then last internal_time + 1 else last internal_time;
                    displayed_time = if gele then last displayed_time else internal_time;
                    gele = last gele <> pause;
            unless start_stop then Stop 
        
    end
tel

node chrono2bis(start_stop, rst, hs : bool) returns (last displayed_time: int = 0)
var last internal_time : int = 0;
    last gele : bool = false;
let
    automaton
        state Stop 
            do 
                    internal_time = if rst and not last gele then 0 else last internal_time;
                    displayed_time = if rst and not last gele then 0 else internal_time;
            unless start_stop continue Running 
        
        state Running
            do 
                    internal_time = if hs then last internal_time + 1 else last internal_time;
                    displayed_time = if gele then last displayed_time else internal_time;
                    gele = last gele <> rst;
            unless start_stop then Stop 
        
    end
tel

node montre(mode, start_stop, rst, hs, pause: bool) returns (heure, minute, seconde: int; last h: int=0;last m: int=0;last s : int=0)
(* var h, m, s: int; *)
(* -- 用于保存当前时间 *)

let
    automaton
        state AfficherHeure 
            do
                s = if (hs and last s < 59) then last s + 1
                    else if (hs and last s = 59) then 0
                    else last s;
                m = if (hs and last s = 59 and last m < 59) then last m + 1
                    else if (hs and last s = 59 and last m = 59) then 0
                    else last m;
                h = if (hs and last s = 59 and last m = 59 and last h < 23) then last h + 1
                else if (hs and last s = 59 and last m = 59 and last h = 23) then 0
                else last h;
                heure = h;
                minute = m;
                seconde = s;

            unless mode continue Chronometre
        
        state Chronometre
            var displayed_time: int;
            do
                
                s = if (hs and last s < 59) then last s + 1
                    else if (hs and last s = 59) then 0
                    else last s;
                m = if (hs and last s = 59 and last m < 59) then last m + 1
                    else if (hs and last s = 59 and last m = 59) then 0
                    else last m;
                h = if (hs and last s = 59 and last m = 59 and last h < 23) then last h + 1
                else if (hs and last s = 59 and last m = 59 and last h = 23) then 0
                else last h;
                
                
                displayed_time = chrono3(start_stop,rst,hs,pause);
                heure = 0 fby displayed_time/3600;
                minute = 0 fby (displayed_time-heure*3600)/60;
                seconde = 0 fby displayed_time-heure*3600-minute*60;

            unless mode continue Reglage

        state Reglage
            var adjustment_state: int;
            do 
                adjustment_state = 0 fby if start_stop then ((adjustment_state + 1) % 3) else adjustment_state;

                s = if (rst and adjustment_state=2 and last s < 59) then last s + 1
                    else if (rst and adjustment_state=2 and last s = 59) then 0
                    else last s;
                m = if (rst and adjustment_state=1 and last m < 59) then last m + 1
                    else if (rst and adjustment_state=1 and last m = 59) then 0
                    else last m;
                h = if (rst and adjustment_state=0 and last h < 23) then last h + 1
                else if (rst and adjustment_state=0 and last h = 23) then 0
                else last h;

                heure = h;
                minute = m;
                seconde = s;
                
                
            unless mode continue AfficherHeure 
        
    end
tel


node watch(hs : bool) returns (hms : int^3)
var last h: int=0;last m: int=0;last s : int=0;
let
    s = 
    if (hs and last s < 59) then last s + 1
        else if (hs and last s = 59) then 0
        else last s;
    m = 
    if (hs and last s = 59 and last m < 59) then last m + 1
        else if (hs and last s = 59 and last m = 59) then 0
        else last m;
    h = 
    if (hs and last s = 59 and last m = 59 and last h < 23) then last h + 1
    else if (hs and last s = 59 and last m = 59 and last h = 23) then 0
    else last h;
    hms = [h,m,s];

tel

node watch2(hs : bool) returns (hms : int^3)
var last m : int = 0;hh,mm,ss:int;
let
    m=if hs then last m+1 else last m;
    ss=(m/1)%4;
    mm=((m/(4*1))%3);
    hh=(m/(12*1)%2);
    hms = [hh,mm,ss];
tel

node affiche_montre(hms : int^3) returns (h,m,s : int)
let
    h = hms[0];
    m = hms[1];
    s = hms[2];
tel

node toto(hs : bool) returns (h,m,s : int)
var hms : int^3;
let
    hms = watch2(hs);
    (h,m,s) = affiche_montre(hms);
tel